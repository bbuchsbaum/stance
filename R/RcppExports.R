# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute FISTA Gradient for CLD
#' 
#' Computes the gradient of the least squares term for FISTA optimization.
#' Supports both full computation and efficient pre-computed WtY mode.
#' 
#' @param Y_or_WtY Either Y (V x T) or pre-computed WtY (K x T) matrix
#' @param W Spatial maps matrix (V x K)
#' @param H_star_X Convolved states matrix (K x T)
#' @param hrf_kernel HRF kernel vector
#' @param precomputed_WtY Logical indicating if first argument is WtY
#' @param WtW_precomp Optional pre-computed W'W matrix (K x K)
#' 
#' @return Gradient matrix (K x T)
#' 
#' @export
compute_gradient_fista_rcpp <- function(Y_or_WtY, W, H_star_X, hrf_kernel, precomputed_WtY = FALSE, WtW_precomp) {
    .Call(`_stance_compute_gradient_fista_rcpp`, Y_or_WtY, W, H_star_X, hrf_kernel, precomputed_WtY, WtW_precomp)
}

#' Compute FISTA Gradient with Pre-computed Terms
#'
#' Simplified version of \code{compute_gradient_fista_rcpp} that operates
#' directly on pre-computed \eqn{W'Y} and \eqn{W'W} matrices.
#'
#' @param WtY Pre-computed \eqn{W'Y} matrix (K x T)
#' @param WtW Pre-computed \eqn{W'W} matrix (K x K)
#' @param H_star_X Convolved states matrix (K x T)
#' @param hrf_kernel HRF kernel vector
#'
#' @return Gradient matrix (K x T)
#'
#' @export
compute_gradient_fista_precomp_rcpp <- function(WtY, WtW, H_star_X, hrf_kernel) {
    .Call(`_stance_compute_gradient_fista_precomp_rcpp`, WtY, WtW, H_star_X, hrf_kernel)
}

#' Transposed Convolution Helper
#' 
#' Performs transposed convolution (correlation) with time-reversed HRF.
#' This is equivalent to convolution with reversed kernel.
#' Supports OpenMP parallelization when available.
#' 
#' @param X Matrix with signals in rows (K x T)
#' @param hrf HRF kernel vector
#' @param n_threads Number of threads to use (0 = auto)
#' 
#' @return Transposed convolution result (K x T)
#' 
#' @keywords internal
convolve_transpose_rcpp <- function(X, hrf, n_threads = 0L) {
    .Call(`_stance_convolve_transpose_rcpp`, X, hrf, n_threads)
}

#' Compute Lipschitz Constant for FISTA
#' 
#' Estimates the Lipschitz constant of the gradient using power method.
#' L = largest eigenvalue of (H'H ⊗ W'W) where ⊗ is Kronecker product.
#' 
#' @param W Spatial maps matrix (V x K)
#' @param hrf_kernel HRF kernel vector
#' @param max_iter Maximum iterations for power method
#' @param tol Convergence tolerance
#' 
#' @return Estimated Lipschitz constant
#' 
#' @export
estimate_lipschitz_rcpp <- function(W, hrf_kernel, max_iter = 30L, tol = 1e-6) {
    .Call(`_stance_estimate_lipschitz_rcpp`, W, hrf_kernel, max_iter, tol)
}

#' Fast Row-wise Convolution
#' 
#' Performs convolution of each row with the HRF kernel.
#' Supports OpenMP parallelization when available.
#' 
#' @param X Matrix with signals in rows (K x T)
#' @param hrf HRF kernel vector
#' @param n_threads Number of threads to use (0 = auto)
#' 
#' @return Convolved matrix (K x T)
#' 
#' @keywords internal
convolve_rows_rcpp <- function(X, hrf, n_threads = 0L) {
    .Call(`_stance_convolve_rows_rcpp`, X, hrf, n_threads)
}

#' Voxel-specific HRF convolution
#'
#' Performs convolution of each row of `design` with each voxel's HRF.
#' Currently always uses direct convolution; `fft_threshold` is kept
#' for compatibility with unit tests.
#'
#' @param design Matrix of regressors (K x T)
#' @param hrfs   Matrix of HRF kernels (V x L)
#' @param fft_threshold Integer threshold for FFT (default 256)
#' @param n_threads Number of threads to use (0 = auto)
#'
#' @return 3D array (V x K x T)
#' @keywords internal
convolve_voxel_hrf_rcpp <- function(design, hrfs, fft_threshold = 256L, n_threads = 0L) {
    .Call(`_stance_convolve_voxel_hrf_rcpp`, design, hrfs, fft_threshold, n_threads)
}

#' Batched FFT convolution for voxel HRFs
#'
#' @param design Matrix of regressors (K x T)
#' @param hrfs Matrix of HRF kernels (V x L)
#' @param n_threads Number of threads
#'
#' @return 3D array (V x K x T)
#' @keywords internal
convolve_voxel_hrf_fft_rcpp <- function(design, hrfs, n_threads = 0L) {
    .Call(`_stance_convolve_voxel_hrf_fft_rcpp`, design, hrfs, n_threads)
}

#' FISTA Solver for CLD
#' 
#' Implements the Fast Iterative Shrinkage-Thresholding Algorithm (FISTA)
#' with Total Variation regularization for continuous state estimation.
#' 
#' @param WtY Pre-computed W'Y matrix (K x T)
#' @param W Spatial maps matrix (V x K)
#' @param hrf_kernel HRF kernel vector
#' @param lambda_tv TV regularization parameter
#' @param L_fista Lipschitz constant
#' @param X_init Initial state matrix (K x T)
#' @param max_iter Maximum iterations
#' @param tol Convergence tolerance
#' @param verbose Print progress
#' 
#' @return List containing:
#'   - X_hat: Estimated states (K x T)
#'   - objective_values: Vector of objective values
#'   - converged: Logical indicating convergence
#'   - iterations: Number of iterations performed
#' 
#' @export
fista_tv_rcpp <- function(WtY, W, hrf_kernel, lambda_tv, L_fista, X_init, max_iter = 100L, tol = 1e-4, verbose = FALSE) {
    .Call(`_stance_fista_tv_rcpp`, WtY, W, hrf_kernel, lambda_tv, L_fista, X_init, max_iter, tol, verbose)
}

#' Compute CLD Objective Function
#' 
#' Evaluates the complete objective function including reconstruction error
#' and TV penalty.
#' 
#' @param Y Data matrix (V x T)
#' @param W Spatial maps (V x K)
#' @param X States (K x T)
#' @param hrf HRF kernel
#' @param lambda_tv TV regularization parameter
#' 
#' @return Objective function value
#' 
#' @export
compute_objective_rcpp <- function(Y, W, X, hrf, lambda_tv) {
    .Call(`_stance_compute_objective_rcpp`, Y, W, X, hrf, lambda_tv)
}

#' Estimate Lipschitz Constant for Low-rank W
#' 
#' Efficiently estimates the Lipschitz constant when W is stored in low-rank form
#' as W = U * diag(S) * V'. Avoids forming the full W matrix.
#' 
#' @param U Left singular vectors (V x r)
#' @param S Singular values (length r)
#' @param V Right singular vectors (K x r)
#' @param hrf_kernel HRF kernel vector
#' 
#' @return Estimated Lipschitz constant
#' 
#' @export
estimate_lipschitz_lowrank_rcpp <- function(U, S, V, hrf_kernel) {
    .Call(`_stance_estimate_lipschitz_lowrank_rcpp`, U, S, V, hrf_kernel)
}

#' Compute W'Y Efficiently Using Low-rank Form
#' 
#' Computes W'Y where W = U * diag(S) * V' without forming full W.
#' 
#' @param U Left singular vectors (V x r)
#' @param S Singular values (length r)
#' @param V Right singular vectors (K x r)
#' @param Y Data matrix (V x T)
#' 
#' @return W'Y matrix (K x T)
#' 
#' @export
compute_WtY_lowrank_rcpp <- function(U, S, V, Y) {
    .Call(`_stance_compute_WtY_lowrank_rcpp`, U, S, V, Y)
}

#' Compute W'W Efficiently Using Low-rank Form
#' 
#' Computes W'W where W = U * diag(S) * V' without forming full W.
#' 
#' @param V Right singular vectors (K x r)
#' @param S Singular values (length r)
#' 
#' @return W'W matrix (K x K)
#' 
#' @export
compute_WtW_lowrank_rcpp <- function(V, S) {
    .Call(`_stance_compute_WtW_lowrank_rcpp`, V, S)
}
#' Log-likelihood calculation kernel
#'
#' Computes log-likelihoods for each state/time point using low-rank
#' projected data.
#'
#' @param Y_proj r x T matrix of projected data
#' @param Vmat K x r matrix of loadings
#' @param hrf_kernel HRF kernel vector
#' @param sigma2 Noise variance
#'
#' @return Matrix of log-likelihoods (K x T)
#' @keywords internal
compute_log_likelihoods_rcpp <- function(Y_proj, Vmat, hrf_kernel, sigma2) {
    .Call(`_stance_compute_log_likelihoods_rcpp`, Y_proj, Vmat, hrf_kernel, sigma2)
}

#' Complete low-rank log-likelihood calculation
#'
#' @param Y_proj r x T matrix of projected data
#' @param U V x r spatial basis
#' @param Vmat K x r matrix of loadings
#' @param H_v V x L basis coefficients
#' @param hrf_basis HRF basis matrix
#' @param S_gamma State posteriors (K x T)
#' @param sigma2 Noise variance
#'
#' @return Matrix of log-likelihoods (K x T)
#' @keywords internal
compute_log_likelihood_lowrank_complete <- function(Y_proj, U, Vmat, H_v, hrf_basis, S_gamma, sigma2) {
    .Call(`_stance_compute_log_likelihood_lowrank_complete`, Y_proj, U, Vmat, H_v, hrf_basis, S_gamma, sigma2)
}

#' Forward Algorithm (Rcpp)
#'
#' Computes scaled forward probabilities for an HMM.
#'
#' @param log_lik Matrix of log-likelihoods (K x T)
#' @param Pi      Transition matrix (K x K)
#' @param pi0     Initial distribution (length K)
#'
#' @return List with `alpha`, `log_likelihood`, and scaling vector `c`.
#' @keywords internal
forward_pass_rcpp <- function(log_lik, Pi, pi0) {
    .Call(`_stance_forward_pass_rcpp`, log_lik, Pi, pi0)
}

#' Backward Algorithm (Rcpp)
#'
#' Computes scaled backward probabilities for an HMM.
#'
#' @param log_lik Matrix of log-likelihoods (K x T)
#' @param Pi      Transition matrix (K x K)
#' @param c_scale Scaling factors from forward pass
#'
#' @return Beta matrix (K x T)
#' @keywords internal
backward_pass_rcpp <- function(log_lik, Pi, c_scale) {
    .Call(`_stance_backward_pass_rcpp`, log_lik, Pi, c_scale)
}

#' Parallel Voxel-wise GLM Fitting
#' 
#' Fits GLMs for multiple voxels in parallel using OpenMP.
#' Each voxel's time series is regressed on the convolved design matrix.
#' 
#' @param Y Data matrix (V x T)
#' @param X_conv Convolved design matrix (T x K)
#' @param n_threads Number of threads to use (0 = auto)
#' @param chunk_size Size of chunks for dynamic scheduling
#' 
#' @return Beta coefficients matrix (V x K)
#' 
#' @export
parallel_glm_fit_rcpp <- function(Y, X_conv, n_threads = 0L, chunk_size = 100L) {
    .Call(`_stance_parallel_glm_fit_rcpp`, Y, X_conv, n_threads, chunk_size)
}

#' Parallel GLM with Regularization
#' 
#' Fits regularized GLMs (Ridge regression) for multiple voxels in parallel.
#' 
#' @param Y Data matrix (V x T)
#' @param X_conv Convolved design matrix (T x K)
#' @param lambda Ridge penalty parameter
#' @param n_threads Number of threads to use (0 = auto)
#' @param chunk_size Size of chunks for dynamic scheduling
#' 
#' @return Beta coefficients matrix (V x K)
#' 
#' @export
parallel_ridge_glm_rcpp <- function(Y, X_conv, lambda = 0.01, n_threads = 0L, chunk_size = 100L) {
    .Call(`_stance_parallel_ridge_glm_rcpp`, Y, X_conv, lambda, n_threads, chunk_size)
}

#' Check OpenMP Support
#' 
#' Returns information about OpenMP availability and configuration.
#' 
#' @return List with OpenMP information
#' 
#' @export
check_openmp_support <- function() {
    .Call(`_stance_check_openmp_support`)
}

#' Proximal Operator for Total Variation Penalty (Condat's Algorithm)
#' 
#' Computes the proximal operator for the 1D Total Variation penalty
#' using Condat's direct algorithm. This solves:
#' argmin_z { 0.5 ||z - x||^2 + lambda * TV(z) }
#' where TV(z) = sum_i |z[i] - z[i-1]|
#' 
#' @param x Input vector
#' @param lambda TV regularization parameter (scaled by step size)
#' 
#' @return Solution vector
#' 
#' @references
#' Condat, L. (2013). A direct algorithm for 1-D total variation denoising.
#' IEEE Signal Processing Letters, 20(11), 1054-1057.
#' 
#' @export
prox_tv_condat_1d <- function(x, lambda) {
    .Call(`_stance_prox_tv_condat_1d`, x, lambda)
}

#' Proximal Operator for TV Penalty on Matrix Rows
#' 
#' Applies the 1D TV proximal operator to each row of a matrix.
#' This is used in FISTA to enforce temporal smoothness on state activations.
#' Supports OpenMP parallelization when available.
#' 
#' @param X Input matrix (K x T)
#' @param lambda_tv TV regularization parameter
#' @param n_threads Number of threads to use (0 = auto)
#' 
#' @return Matrix with TV-denoised rows
#' 
#' @export
prox_tv_condat_rcpp <- function(X, lambda_tv, n_threads = 0L) {
    .Call(`_stance_prox_tv_condat_rcpp`, X, lambda_tv, n_threads)
}

#' Compute Total Variation of Matrix Rows
#' 
#' Computes the sum of total variations across all rows.
#' TV(X) = sum_k sum_t |X[k,t] - X[k,t-1]|
#' 
#' @param X Input matrix (K x T)
#' 
#' @return Total variation value
#' 
#' @export
compute_tv_rcpp <- function(X) {
    .Call(`_stance_compute_tv_rcpp`, X)
}

#' Alternative TV Proximal Operator using Dual Method
#' 
#' Implements TV proximal operator using dual formulation.
#' This can be more stable for certain cases.
#' 
#' @param x Input vector
#' @param lambda TV regularization parameter
#' @param max_iter Maximum iterations
#' @param tol Convergence tolerance
#' 
#' @return Solution vector
#' 
#' @keywords internal
prox_tv_dual <- function(x, lambda, max_iter = 100L, tol = 1e-8) {
    .Call(`_stance_prox_tv_dual`, x, lambda, max_iter, tol)
}

#' Batched HRF coefficient update
#'
#' Estimates HRF coefficients for each voxel in batches using a
#' ridge-stabilised solver.
#'
#' @param Y Data matrix (V x T)
#' @param hrf_basis HRF basis matrix (T x L)
#' @param ridge Small ridge penalty
#' @param block_size Number of voxels per batch
#'
#' @return Matrix of HRF coefficients (V x L)
#' @keywords internal
update_hrf_coefficients_batched_cpp <- function(Y, hrf_basis, ridge = 1e-6, block_size = 64L) {
    .Call(`_stance_update_hrf_coefficients_batched_cpp`, Y, hrf_basis, ridge, block_size)
}

